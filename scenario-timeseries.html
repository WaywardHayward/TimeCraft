<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TimeCraft - Scenario Time Series Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        .chart-container {
            position: relative;
            height: 400px;
            width: 100%;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-6xl">
        <!-- Header -->
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-800 mb-2">TimeCraft</h1>
            <p class="text-xl text-gray-600">Scenario-Based Time Series Generator</p>
            <p class="text-sm text-gray-500 mt-2">Generate aggregate time series data from your scenario descriptions</p>
            <div class="mt-4 p-3 bg-blue-50 border border-blue-200 rounded-md">
                <p class="text-sm text-blue-700">
                    <strong>Note:</strong> This interface connects to the TimeCraft API server on port 8080. 
                    Please ensure the API server is running for full functionality.
                </p>
            </div>
        </div>

        <!-- Input Section -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-8">
            <h2 class="text-2xl font-semibold text-gray-800 mb-4">Time Series Generation</h2>
            <div class="mb-4">
                <label for="scenarioText" class="block text-sm font-medium text-gray-700 mb-2">
                    Scenario Description
                </label>
                <div class="flex gap-4">
                    <div class="flex-grow">
                        <textarea 
                            id="scenarioText" 
                            rows="4" 
                            class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                            placeholder="Example: A smart factory monitoring system tracking temperature, pressure, and vibration sensors across different production lines during a 24-hour manufacturing cycle..."
                        ></textarea>
                    </div>
                    <div class="flex flex-col gap-2">
                        <button 
                            id="generateBtn" 
                            class="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-6 rounded-md transition duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
                            onclick="generateTimeSeriesMain()"
                        >
                            Generate Time Series
                        </button>
                        <button 
                            id="exportBtn" 
                            class="bg-green-600 hover:bg-green-700 text-white font-medium py-2 px-6 rounded-md transition duration-200 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 disabled:bg-gray-400 disabled:cursor-not-allowed"
                            onclick="exportToCSV()"
                            disabled
                        >
                            Export CSV
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Progress Bar -->
            <div id="progressSection" class="mb-6 hidden">
                <div class="flex justify-between items-center mb-2">
                    <h3 class="text-lg font-semibold text-gray-800">Generation Progress</h3>
                    <span id="progressText" class="text-sm text-gray-600">0%</span>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-4">
                    <div id="progressBar" class="bg-blue-600 h-4 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
                <div id="progressStatus" class="text-sm text-gray-600 mt-2">Preparing...</div>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                <div>
                    <label for="numTags" class="block text-sm font-medium text-gray-700 mb-2">Number of Tags</label>
                    <input 
                        type="number" 
                        id="numTags" 
                        min="0" 
                        max="100" 
                        value="5" 
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                        placeholder="Enter number of tags (0-100)"
                    />
                </div>
                <div>
                    <label for="dataLength" class="block text-sm font-medium text-gray-700 mb-2">Data Points</label>
                    <select id="dataLength" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="24">24 Hours</option>
                        <option value="48">48 Hours</option>
                        <option value="168" selected>1 Week (168 Hours)</option>
                        <option value="720">1 Month (720 Hours)</option>
                    </select>
                </div>
                <div>
                    <label for="frequency" class="block text-sm font-medium text-gray-700 mb-2">Frequency</label>
                    <select id="frequency" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="hourly" selected>Hourly</option>
                        <option value="daily">Daily</option>
                        <option value="weekly">Weekly</option>
                    </select>
                </div>
            </div>
            
            <!-- Progressive Mode Toggle -->
            <div class="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-md">
                <div class="flex items-center justify-between">
                    <div>
                        <h3 class="text-sm font-medium text-blue-800">Progressive Generation</h3>
                        <p class="text-xs text-blue-600 mt-1">Enable progressive generation with real-time progress bar and chart updates</p>
                    </div>
                    <div class="flex items-center">
                        <label class="flex items-center">
                            <input type="checkbox" id="progressiveMode" checked class="mr-3 h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500 focus:ring-2">
                            <span class="text-sm text-blue-700 font-medium">Enable Progressive Mode</span>
                        </label>
                    </div>
                </div>
            </div>

            <!-- Stock Scenario Section -->
            <div class="mt-8 pt-6 border-t border-gray-200">
                <h3 class="text-xl font-semibold text-gray-800 mb-4">Product Stock Scenario</h3>
                <div class="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-md">
                    <p class="text-sm text-blue-700">
                        <strong>How it works:</strong> Enter your scenario description below and click "Generate Stock Data" to 
                        create product inventory and order data based on your description.
                    </p>
                </div>
                <div class="flex gap-4">
                    <div class="flex-grow">
                        <textarea 
                            id="stockScenarioText" 
                            rows="3" 
                            class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                            placeholder="Example: Generate stock data for an electronics store with gaming laptops, smartphones, and tablets, including varied price ranges and stock levels..."
                        ></textarea>
                    </div>
                    <div>
                        <button 
                            id="generateStockBtn" 
                            class="h-full bg-purple-600 hover:bg-purple-700 text-white font-medium px-6 rounded-md transition duration-200 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2"
                            onclick="generateStockData()"
                        >
                            Generate<br>Stock Data
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Results Section -->
        <div id="resultsSection" class="bg-white rounded-lg shadow-md p-6 hidden">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-semibold text-gray-800">Generated Time Series</h2>
                <div class="text-sm text-gray-600">
                    <span id="generationInfo"></span>
                </div>
            </div>
            
            <!-- Chart -->
            <div class="chart-container mb-6">
                <canvas id="timeSeriesChart"></canvas>
            </div>

            <!-- Statistics -->
            <div id="statisticsSection" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
                <!-- Statistics will be populated here -->
            </div>

            <!-- Data Preview -->
            <div class="mb-4">
                <h3 class="text-lg font-semibold text-gray-800 mb-2">Data Preview</h3>
                <div class="bg-gray-50 rounded-lg p-4 max-h-64 overflow-y-auto">
                    <pre id="dataPreview" class="text-sm text-gray-700"></pre>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentData = null;
        let chart = null;

        // Mock time series generation functions
        function generateSinePattern(length, baseValue, amplitude, frequency, phase, noise) {
            const data = [];
            for (let i = 0; i < length; i++) {
                const value = baseValue + Math.sin(i * frequency + phase) * amplitude + (Math.random() - 0.5) * noise;
                data.push(Math.round(value * 100) / 100);
            }
            return data;
        }

        function generateLinearPattern(length, baseValue, slope, noise) {
            const data = [];
            for (let i = 0; i < length; i++) {
                const value = baseValue + i * slope + (Math.random() - 0.5) * noise;
                data.push(Math.round(value * 100) / 100);
            }
            return data;
        }

        function generateSeasonalPattern(length, baseValue, amplitude, period, noise) {
            const data = [];
            for (let i = 0; i < length; i++) {
                const seasonal = Math.sin(2 * Math.PI * i / period) * amplitude;
                const trend = baseValue + i * 0.01;
                const value = trend + seasonal + (Math.random() - 0.5) * noise;
                data.push(Math.round(value * 100) / 100);
            }
            return data;
        }

        function generateRandomWalkPattern(length, startValue, stepSize) {
            const data = [startValue];
            for (let i = 1; i < length; i++) {
                const step = (Math.random() - 0.5) * stepSize;
                const value = data[i-1] + step;
                data.push(Math.round(value * 100) / 100);
            }
            return data;
        }

        function generateTagNamesFromScenario(scenario, numTags) {
            // Simple tag generation based on common keywords
            const keywordMapping = {
                'temperature': ['Temperature_Sensor_1', 'Temperature_Sensor_2', 'Ambient_Temperature'],
                'pressure': ['Pressure_Gauge_1', 'Pressure_Gauge_2', 'System_Pressure'],
                'vibration': ['Vibration_X', 'Vibration_Y', 'Vibration_Z'],
                'factory': ['Production_Rate', 'Machine_Efficiency', 'Power_Consumption'],
                'energy': ['Power_Output', 'Voltage', 'Current'],
                'sensor': ['Sensor_A', 'Sensor_B', 'Sensor_C'],
                'monitoring': ['CPU_Usage', 'Memory_Usage', 'Network_Traffic'],
                'financial': ['Stock_Price', 'Trading_Volume', 'Market_Index'],
                'weather': ['Temperature', 'Humidity', 'Wind_Speed'],
                'traffic': ['Vehicle_Count', 'Speed_Average', 'Congestion_Level']
            };

            const tags = [];
            const lowerScenario = scenario.toLowerCase();
            
            // Find matching keywords and generate appropriate tags
            for (const [keyword, tagList] of Object.entries(keywordMapping)) {
                if (lowerScenario.includes(keyword)) {
                    tags.push(...tagList);
                    if (tags.length >= numTags) break;
                }
            }

            // Fill remaining slots with generic tags
            while (tags.length < numTags) {
                tags.push(`Tag_${tags.length + 1}`);
            }

            return tags.slice(0, numTags);
        }

        function generateMockTimeSeries() {
            const scenario = document.getElementById('scenarioText').value || 'Generic monitoring scenario';
            const numTags = parseInt(document.getElementById('numTags').value);
            const length = parseInt(document.getElementById('dataLength').value);
            const frequency = document.getElementById('frequency').value;

            // Generate tag names based on scenario
            const tagNames = generateTagNamesFromScenario(scenario, numTags);
            
            const timeSeriesData = {};
            const patterns = ['sine', 'linear', 'seasonal', 'randomwalk', 'mixed'];

            tagNames.forEach((tag, index) => {
                const pattern = patterns[index % patterns.length];
                let data;

                switch (pattern) {
                    case 'sine':
                        data = generateSinePattern(length, 50 + index * 20, 15, 0.1 + index * 0.05, index, 5);
                        break;
                    case 'linear':
                        data = generateLinearPattern(length, 30 + index * 15, 0.1 + index * 0.05, 3);
                        break;
                    case 'seasonal':
                        data = generateSeasonalPattern(length, 40 + index * 10, 20, 24, 4);
                        break;
                    case 'randomwalk':
                        data = generateRandomWalkPattern(length, 60 + index * 10, 2);
                        break;
                    default: // mixed
                        const base = generateSinePattern(length, 45 + index * 12, 10, 0.08, index, 2);
                        const trend = generateLinearPattern(length, 0, 0.05, 1);
                        data = base.map((val, i) => Math.round((val + trend[i]) * 100) / 100);
                }

                timeSeriesData[tag] = data;
            });

            return {
                scenario: scenario,
                tagNames: tagNames,
                length: length,
                frequency: frequency,
                timeSeries: timeSeriesData,
                timestamp: new Date().toISOString()
            };
        }

        // Main generation function that chooses between progressive and traditional modes
        function generateTimeSeriesMain() {
            const progressiveMode = document.getElementById('progressiveMode').checked;
            
            if (progressiveMode) {
                generateTimeSeriesProgressive();
            } else {
                generateTimeSeries();
            }
        }

        // Progressive generation functions
        function updateProgress(percentage, status) {
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const progressStatus = document.getElementById('progressStatus');
            
            progressBar.style.width = percentage + '%';
            progressText.textContent = Math.round(percentage) + '%';
            progressStatus.textContent = status;
        }

        function showProgressSection() {
            document.getElementById('progressSection').classList.remove('hidden');
        }

        function hideProgressSection() {
            document.getElementById('progressSection').classList.add('hidden');
        }

        async function generateTimeSeriesProgressive() {
            const generateBtn = document.getElementById('generateBtn');
            
            const scenario = document.getElementById('scenarioText').value || 'Generic monitoring scenario';
            const numTagsInput = document.getElementById('numTags').value;
            const numTags = parseInt(numTagsInput);
            
            // Validate number of tags
            if (isNaN(numTags) || numTags < 0 || numTags > 100) {
                alert('Please enter a valid number of tags between 0 and 100.');
                return;
            }
            
            generateBtn.disabled = true;
            generateBtn.textContent = 'Generating...';
            showProgressSection();
            
            const length = parseInt(document.getElementById('dataLength').value);
            const frequency = document.getElementById('frequency').value;

            try {
                // Step 1: Generate tags (10% progress)
                updateProgress(5, 'Generating tag names...');
                
                const tagRequest = {
                    text_description: scenario,
                    num_tags: numTags,
                    sequence_length: length
                };

                const tagResponse = await fetch('/generate-tags', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(tagRequest)
                });

                if (!tagResponse.ok) {
                    throw new Error(`Failed to generate tags: ${tagResponse.status}`);
                }

                const tagData = await tagResponse.json();
                updateProgress(10, `Generated ${tagData.tags.length} tag names`);
                
                // Initialize current data structure
                currentData = {
                    scenario: scenario,
                    tagNames: tagData.tags,
                    length: length,
                    frequency: frequency,
                    timeSeries: {},
                    timestamp: new Date().toISOString(),
                    apiStatus: tagData.status,
                    apiMessage: tagData.message
                };

                // Show initial results with empty chart
                displayInitialResults();

                // Step 2: Generate timeseries for each tag progressively
                const progressPerTag = 80 / tagData.tags.length; // 80% total for all tags
                
                for (let i = 0; i < tagData.tags.length; i++) {
                    const tag = tagData.tags[i];
                    const currentProgress = 10 + (i * progressPerTag);
                    
                    updateProgress(currentProgress, `Generating data for ${tag}...`);
                    
                    const tsRequest = {
                        tag_name: tag,
                        text_description: scenario,
                        sequence_length: length,
                        tag_index: i
                    };

                    const tsResponse = await fetch('/generate-timeseries-for-tag', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(tsRequest)
                    });

                    if (!tsResponse.ok) {
                        console.warn(`Failed to generate timeseries for ${tag}: ${tsResponse.status}`);
                        // Generate mock data as fallback
                        currentData.timeSeries[tag] = generateMockTimeseriesForTag(length, i);
                    } else {
                        const tsData = await tsResponse.json();
                        currentData.timeSeries[tag] = tsData.timeseries;
                    }
                    
                    // Update chart with new data
                    updateChartWithNewTag(tag, currentData.timeSeries[tag]);
                    updateProgress(10 + ((i + 1) * progressPerTag), `Generated data for ${tag}`);
                    
                    // Small delay to show progress visually
                    await new Promise(resolve => setTimeout(resolve, 200));
                }

                // Step 3: Finalize (remaining 10%)
                updateProgress(95, 'Finalizing results...');
                displayFinalResults();
                updateProgress(100, 'Generation complete!');
                
                // Hide progress after a short delay
                setTimeout(() => {
                    hideProgressSection();
                }, 2000);
                
                document.getElementById('exportBtn').disabled = false;

            } catch (error) {
                console.error('Error during progressive generation:', error);
                updateProgress(0, 'Generation failed');
                alert('Error generating timeseries: ' + error.message);
                hideProgressSection();
            } finally {
                generateBtn.disabled = false;
                generateBtn.textContent = 'Generate Time Series';
            }
        }

        function generateMockTimeseriesForTag(length, tagIndex) {
            // Generate different patterns based on tag index
            const patterns = ['sine', 'linear', 'seasonal', 'randomwalk'];
            const pattern = patterns[tagIndex % patterns.length];
            
            switch (pattern) {
                case 'sine':
                    return generateSinePattern(length, 50 + tagIndex * 20, 15, 0.1 + tagIndex * 0.05, tagIndex, 5);
                case 'linear':
                    return generateLinearPattern(length, 30 + tagIndex * 15, 0.1 + tagIndex * 0.05, 3);
                case 'seasonal':
                    return generateSeasonalPattern(length, 40 + tagIndex * 10, 20, 24, 4);
                case 'randomwalk':
                    return generateRandomWalkPattern(length, 60 + tagIndex * 10, 2);
                default:
                    const base = generateSinePattern(length, 45 + tagIndex * 12, 10, 0.08, tagIndex, 2);
                    const trend = generateLinearPattern(length, 0, 0.05, 1);
                    return base.map((val, i) => Math.round((val + trend[i]) * 100) / 100);
            }
        }

        function displayInitialResults() {
            // Show results section
            document.getElementById('resultsSection').classList.remove('hidden');

            // Update generation info
            const tagCount = currentData.tagNames ? currentData.tagNames.length : 0;
            const length = currentData.length || 0;
            const frequency = currentData.frequency || 'unknown';
            
            let infoText = `${tagCount} tags, ${length} points (${frequency}) - In progress...`;
            document.getElementById('generationInfo').textContent = infoText;

            // Create empty chart
            createEmptyChart();

            // Clear statistics and preview
            document.getElementById('statisticsSection').innerHTML = '<div class="text-gray-500">Generating data...</div>';
            document.getElementById('dataPreview').textContent = 'Data preview will be available after generation completes...';

            // Scroll to results
            document.getElementById('resultsSection').scrollIntoView({ behavior: 'smooth' });
        }

        function createEmptyChart() {
            const ctx = document.getElementById('timeSeriesChart').getContext('2d');
            
            // Destroy existing chart if it exists
            if (chart) {
                chart.destroy();
            }

            const labels = Array.from({ length: currentData.length }, (_, i) => {
                if (currentData.frequency === 'hourly') {
                    return `H${i + 1}`;
                } else if (currentData.frequency === 'daily') {
                    return `D${i + 1}`;
                } else {
                    return `W${i + 1}`;
                }
            });

            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Generated Time Series Data (In Progress)'
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: `Time (${currentData.frequency})`
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Value'
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });
        }

        function updateChartWithNewTag(tagName, data) {
            if (!chart) return;

            const colors = [
                '#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6',
                '#EC4899', '#06B6D4', '#84CC16', '#F97316', '#6366F1'
            ];

            const colorIndex = chart.data.datasets.length % colors.length;
            
            const newDataset = {
                label: tagName,
                data: data,
                borderColor: colors[colorIndex],
                backgroundColor: colors[colorIndex] + '20',
                borderWidth: 2,
                fill: false,
                tension: 0.1
            };

            chart.data.datasets.push(newDataset);
            chart.update();
        }

        function displayFinalResults() {
            // Update generation info to show completion
            const tagCount = currentData.tagNames ? currentData.tagNames.length : 0;
            const length = currentData.length || 0;
            const frequency = currentData.frequency || 'unknown';
            
            let infoText = `${tagCount} tags, ${length} points (${frequency}) - Complete`;
            if (currentData.apiStatus && currentData.apiStatus === 'demo_mode') {
                infoText += ' - Demo Mode';
            }
            document.getElementById('generationInfo').textContent = infoText;

            // Update chart title
            if (chart) {
                chart.options.plugins.title.text = 'Generated Time Series Data';
                chart.update();
            }

            // Display statistics
            displayStatistics();

            // Display data preview
            displayDataPreview();
        }

        // Keep original function for backward compatibility
        function generateTimeSeries() {
            const generateBtn = document.getElementById('generateBtn');
            
            const scenario = document.getElementById('scenarioText').value || 'Generic monitoring scenario';
            const numTagsInput = document.getElementById('numTags').value;
            const numTags = parseInt(numTagsInput);
            
            // Validate number of tags
            if (isNaN(numTags) || numTags < 0 || numTags > 100) {
                alert('Please enter a valid number of tags between 0 and 100.');
                return;
            }
            
            generateBtn.disabled = true;
            generateBtn.textContent = 'Generating...';

            const length = parseInt(document.getElementById('dataLength').value);
            const frequency = document.getElementById('frequency').value;

            // Prepare request data for the API
            const requestData = {
                text_description: scenario,
                num_tags: numTags,
                sequence_length: length
            };

            // Call the API endpoint
            fetch('/generate-aggregate-timeseries', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestData)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                // Transform API response to match our existing data structure
                // Handle cases where response might not have all expected fields
                currentData = {
                    scenario: data.text_description || 'Unknown scenario',
                    tagNames: data.tags || [],
                    length: data.sequence_length || 0,
                    frequency: frequency,
                    timeSeries: data.generated_timeseries || {}, // Fixed key name
                    timestamp: new Date().toISOString(),
                    apiStatus: data.status || 'unknown',
                    apiMessage: data.message || null
                };
                
                displayResults();
                document.getElementById('exportBtn').disabled = false;
            })
            .catch(error => {
                console.error('Error calling API:', error);
                alert('API server not available. This page requires the TimeCraft API server to be running on port 8080. Please start the server using: python api_server.py');
            })
            .finally(() => {
                generateBtn.disabled = false;
                generateBtn.textContent = 'Generate Time Series';
            });
        }

        function displayResults() {
            if (!currentData) return;

            // Show results section
            document.getElementById('resultsSection').classList.remove('hidden');

            // Update generation info - handle cases where tagNames might be undefined
            const tagCount = currentData.tagNames ? currentData.tagNames.length : 0;
            const length = currentData.length || 0;
            const frequency = currentData.frequency || 'unknown';
            
            let infoText = `${tagCount} tags, ${length} points (${frequency})`;
            if (currentData.apiStatus && currentData.apiStatus === 'demo_mode') {
                infoText += ' - Demo Mode';
            }
            document.getElementById('generationInfo').textContent = infoText;

            // Create chart
            createChart();

            // Display statistics
            displayStatistics();

            // Display data preview
            displayDataPreview();

            // Scroll to results
            document.getElementById('resultsSection').scrollIntoView({ behavior: 'smooth' });
        }

        function createChart() {
            const ctx = document.getElementById('timeSeriesChart').getContext('2d');
            
            // Destroy existing chart if it exists
            if (chart) {
                chart.destroy();
            }

            const colors = [
                '#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6',
                '#EC4899', '#06B6D4', '#84CC16', '#F97316', '#6366F1'
            ];

            const datasets = Object.entries(currentData.timeSeries).map(([tag, data], index) => ({
                label: tag,
                data: data,
                borderColor: colors[index % colors.length],
                backgroundColor: colors[index % colors.length] + '20',
                borderWidth: 2,
                fill: false,
                tension: 0.1
            }));

            const labels = Array.from({ length: currentData.length }, (_, i) => {
                if (currentData.frequency === 'hourly') {
                    return `H${i + 1}`;
                } else if (currentData.frequency === 'daily') {
                    return `D${i + 1}`;
                } else {
                    return `W${i + 1}`;
                }
            });

            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Generated Time Series Data'
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: `Time (${currentData.frequency})`
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Value'
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });
        }

        function displayStatistics() {
            const statsSection = document.getElementById('statisticsSection');
            statsSection.innerHTML = '';

            Object.entries(currentData.timeSeries).forEach(([tag, data]) => {
                const mean = data.reduce((sum, val) => sum + val, 0) / data.length;
                const variance = data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / data.length;
                const stdDev = Math.sqrt(variance);
                const min = Math.min(...data);
                const max = Math.max(...data);

                const statCard = document.createElement('div');
                statCard.className = 'bg-gray-50 rounded-lg p-4';
                statCard.innerHTML = `
                    <h4 class="font-semibold text-gray-800 mb-2">${tag}</h4>
                    <div class="space-y-1 text-sm text-gray-600">
                        <div>Mean: ${mean.toFixed(2)}</div>
                        <div>Std Dev: ${stdDev.toFixed(2)}</div>
                        <div>Min: ${min.toFixed(2)}</div>
                        <div>Max: ${max.toFixed(2)}</div>
                    </div>
                `;
                statsSection.appendChild(statCard);
            });
        }

        function displayDataPreview() {
            const preview = document.getElementById('dataPreview');
            
            // Handle case where tagNames might be undefined
            if (!currentData.tagNames || !currentData.timeSeries) {
                preview.textContent = 'No data available for preview';
                return;
            }
            
            let previewText = 'Time\t' + currentData.tagNames.join('\t') + '\n';
            
            const maxPreviewRows = 10;
            for (let i = 0; i < Math.min(maxPreviewRows, currentData.length); i++) {
                const row = [i + 1].concat(
                    currentData.tagNames.map(tag => currentData.timeSeries[tag] ? currentData.timeSeries[tag][i] : 'N/A')
                );
                previewText += row.join('\t') + '\n';
            }
            
            if (currentData.length > maxPreviewRows) {
                previewText += '...\n';
                previewText += `(${currentData.length - maxPreviewRows} more rows)`;
            }
            
            preview.textContent = previewText;
        }

        function exportToCSV() {
            if (!currentData || !currentData.tagNames || !currentData.timeSeries) {
                alert('No data available for export');
                return;
            }

            // Create CSV content with timestamps
            let csvContent = 'Timestamp,' + currentData.tagNames.join(',') + '\n';
            
            // Generate timestamps based on frequency
            const frequency = currentData.frequency || 'hourly';
            let timeUnit = 'H';
            if (frequency === 'daily') timeUnit = 'D';
            if (frequency === 'weekly') timeUnit = 'W';
            
            for (let i = 0; i < currentData.length; i++) {
                const timestamp = `${timeUnit}${i + 1}`;
                const row = [timestamp].concat(
                    currentData.tagNames.map(tag => 
                        currentData.timeSeries[tag] && currentData.timeSeries[tag][i] !== undefined 
                            ? currentData.timeSeries[tag][i] 
                            : 'N/A'
                    )
                );
                csvContent += row.join(',') + '\n';
            }

            // Create and download file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                
                // Create filename with timestamp and scenario info
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const scenarioName = currentData.scenario ? 
                    currentData.scenario.substring(0, 30).replace(/[^a-zA-Z0-9]/g, '_') : 
                    'timeseries';
                link.setAttribute('download', `${scenarioName}_${timestamp}.csv`);
                
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Show success message
                const exportBtn = document.getElementById('exportBtn');
                const originalText = exportBtn.textContent;
                exportBtn.textContent = 'Downloaded!';
                exportBtn.classList.add('bg-green-600');
                exportBtn.classList.remove('bg-green-600');
                
                setTimeout(() => {
                    exportBtn.textContent = originalText;
                    exportBtn.classList.remove('bg-green-700');
                    exportBtn.classList.add('bg-green-600');
                }, 2000);
            }
        }

        async function checkApiAuthentication() {
            try {
                const response = await fetch('https://stock-manager-nhm4youwosiha.azurewebsites.net/api/Products', {
                    method: 'GET',
                    credentials: 'include',
                    headers: {
                        'accept': 'application/json'
                    }
                });
                
                if (response.status === 401 || response.status === 403) {
                    return false;
                }
                return response.ok;
            } catch (error) {
                console.error('Authentication check failed:', error);
                return false;
            }
        }

        async function ensureAuthenticated() {
            const isAuthenticated = await checkApiAuthentication();
            if (!isAuthenticated) {
                // Show a more informative message
                const retryAuth = confirm(
                    'You need to log in to the Stock Manager to generate stock data. ' +
                    'Would you like to open the login page now?\n\n' +
                    'After logging in, close the login window and click "Generate Stock Data" again.'
                );
                
                if (retryAuth) {
                    // Open login page in a new window
                    const loginWindow = window.open('https://stock-manager-nhm4youwosiha.azurewebsites.net/login', '_blank');
                    if (loginWindow) {
                        loginWindow.focus();
                    } else {
                        alert('Pop-up was blocked. Please enable pop-ups for this site and try again.');
                    }
                }
                return false;
            }
            return true;
        }

        async function handleApiError(error, operation) {
            console.error(`Error during ${operation}:`, error);
            
            if (error.message.includes('Authentication required') || error.status === 401 || error.status === 403) {
                return await ensureAuthenticated();
            }
            
            // Show a user-friendly error message
            alert(`Error ${operation}: ${error.message || 'Unknown error occurred'}. Please try again.`);
            return false;
        }

        // Demo mode stock data generation
        function generateDemoProducts(description) {
            const categories = ['Electronics', 'Computers', 'Smartphones', 'Accessories', 'Gaming'];
            const products = [];
            
            // Extract potential product types from description
            const words = description.toLowerCase().split(/\s+/);
            const productTypes = words.filter(word => 
                ['laptop', 'phone', 'tablet', 'computer', 'desktop', 'monitor', 'keyboard', 'mouse'].includes(word)
            );

            const count = Math.min(Math.max(productTypes.length, 3), 8); // Generate 3-8 products

            for (let i = 0; i < count; i++) {
                const basePrice = 100 + Math.random() * 900;
                const stockLevel = Math.floor(Math.random() * 100);
                const productType = productTypes[i] || 'Product';
                
                products.push({
                    id: `DEMO-${i + 1}`,
                    name: `${['Premium', 'Standard', 'Pro', 'Basic'][Math.floor(Math.random() * 4)]} ${
                        productType.charAt(0).toUpperCase() + productType.slice(1)
                    }`,
                    category: categories[Math.floor(Math.random() * categories.length)],
                    stockLevel: stockLevel,
                    price: Math.round(basePrice * 100) / 100,
                    status: stockLevel > 50 ? 'In Stock' : stockLevel > 20 ? 'Low Stock' : 'Critical Stock'
                });
            }
            
            return products;
        }

        function generateDemoOrders(products) {
            const orders = [];
            const statuses = ['Completed', 'Pending', 'Processing'];
            
            const orderCount = Math.min(products.length * 2, 10); // Generate up to 10 orders
            
            for (let i = 0; i < orderCount; i++) {
                const product = products[Math.floor(Math.random() * products.length)];
                const quantity = Math.floor(Math.random() * 5) + 1;
                
                orders.push({
                    id: `ORDER-${i + 1}`,
                    productName: product.name,
                    quantity: quantity,
                    status: statuses[Math.floor(Math.random() * statuses.length)],
                    pricePerUnit: product.price,
                    total: Math.round(quantity * product.price * 100) / 100
                });
            }
            
            return orders;
        }

        async function generateStockData() {
            const generateBtn = document.getElementById('generateStockBtn');
            const description = document.getElementById('stockScenarioText').value;
            
            if (!description) {
                alert('Please enter a stock scenario description');
                return;
            }

            try {
                generateBtn.disabled = true;
                generateBtn.textContent = 'Generating...';

                // Parse the description to extract potential product details
                const words = description.toLowerCase().split(/\s+/);
                const productTypes = words.filter(word => 
                    ['laptop', 'phone', 'tablet', 'computer', 'desktop', 'monitor', 'keyboard', 'mouse'].includes(word)
                );
                
                const productType = productTypes[0] || 'Product';
                const categories = ['Electronics', 'Computers', 'Accessories'];
                
                // Create the request body - send the Product object directly
                const productData = {
                    Name: `${productType.charAt(0).toUpperCase() + productType.slice(1)} ${Math.floor(Math.random() * 1000)}`,
                    Description: description,
                    Category: categories[Math.floor(Math.random() * categories.length)],
                    Price: Math.floor(Math.random() * 900) + 100, // Random price between 100 and 1000
                    StockLevel: Math.floor(Math.random() * 100) // Random stock between 0 and 100
                };

                console.log('Sending product data:', productData);

                const createProductResponse = await fetch('https://stock-manager-nhm4youwosiha.azurewebsites.net/api/Products', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'accept': 'application/json'
                    },
                    body: JSON.stringify(productData)
                });

                if (!createProductResponse.ok) {
                    const errorText = await createProductResponse.text();
                    console.error('Product creation error:', errorText);
                    throw new Error(`Failed to create product (${createProductResponse.status}): ${errorText}`);
                }

                const createdProduct = await createProductResponse.json();
                console.log('Created product:', createdProduct);

                // Get all products
                const productsResponse = await fetch('https://stock-manager-nhm4youwosiha.azurewebsites.net/api/Products', {
                    headers: {
                        'accept': 'application/json'
                    }
                });

                if (!productsResponse.ok) {
                    throw new Error(`Failed to get products (${productsResponse.status})`);
                }

                const products = await productsResponse.json();
                console.log('Retrieved products:', products);

                if (products && products.length > 0) {
                    // Create a new order - send the Order object directly
                    const orderData = {
                        ProductId: products[0].id, // Note: API likely returns lowercase property names
                        Quantity: Math.floor(Math.random() * 5) + 1,
                        Status: "Pending"
                    };

                    console.log('Sending order data:', orderData);

                    const createOrderResponse = await fetch('https://stock-manager-nhm4youwosiha.azurewebsites.net/api/ProductOrders', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'accept': 'application/json'
                        },
                        body: JSON.stringify(orderData)
                    });

                    if (!createOrderResponse.ok) {
                        const errorText = await createOrderResponse.text();
                        console.error('Order creation error:', errorText);
                        throw new Error(`Failed to create order (${createOrderResponse.status}): ${errorText}`);
                    }

                    // Get all orders
                    const ordersResponse = await fetch('https://stock-manager-nhm4youwosiha.azurewebsites.net/api/ProductOrders', {
                        headers: {
                            'accept': 'application/json'
                        }
                    });

                    if (!ordersResponse.ok) {
                        throw new Error(`Failed to get orders (${ordersResponse.status})`);
                    }

                    const orders = await ordersResponse.json();
                    console.log('Retrieved orders:', orders);

                    // Display results
                    displayStockResults(products, orders);
                } else {
                    throw new Error('No products available to create orders');
                }

            } catch (error) {
                console.error('Error generating stock data:', error);
                alert('Error: ' + error.message + '\nPlease check the console for more details.');
            } finally {
                generateBtn.disabled = false;
                generateBtn.textContent = 'Generate Stock Data';
            }
        }

        function displayStockResults(products, orders) {
            const stockResultsDiv = document.createElement('div');
            stockResultsDiv.className = 'bg-white rounded-lg shadow-md p-6 mb-8';
            stockResultsDiv.innerHTML = `
                <h3 class="text-xl font-semibold text-gray-800 mb-4">Generated Stock Data</h3>
                
                <!-- Products Table -->
                <div class="mb-6">
                    <h4 class="text-lg font-medium text-gray-700 mb-3">Products</h4>
                    <div class="overflow-x-auto">
                        <table class="min-w-full divide-y divide-gray-200">
                            <thead class="bg-gray-50">
                                <tr>
                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Product Name</th>
                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Category</th>
                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Stock Level</th>
                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Price</th>
                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                                </tr>
                            </thead>
                            <tbody class="bg-white divide-y divide-gray-200">
                                ${products.map(product => `
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">${product.name || 'N/A'}</td>
                                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${product.category || 'N/A'}</td>
                                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${product.stockLevel || 0}</td>
                                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">$${(product.price || 0).toFixed(2)}</td>
                                        <td class="px-6 py-4 whitespace-nowrap">
                                            <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                                                (product.stockLevel || 0) > 50 ? 'bg-green-100 text-green-800' : 
                                                (product.stockLevel || 0) > 20 ? 'bg-yellow-100 text-yellow-800' : 
                                                'bg-red-100 text-red-800'
                                            }">
                                                ${(product.stockLevel || 0) > 50 ? 'In Stock' : 
                                                  (product.stockLevel || 0) > 20 ? 'Low Stock' : 
                                                  'Critical Stock'}
                                            </span>
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Orders Table -->
                <div class="mt-8">
                    <h4 class="text-lg font-medium text-gray-700 mb-3">Recent Orders</h4>
                    <div class="overflow-x-auto">
                        <table class="min-w-full divide-y divide-gray-200">
                            <thead class="bg-gray-50">
                                <tr>
                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Order ID</th>
                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Product</th>
                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Quantity</th>
                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Total</th>
                                </tr>
                            </thead>
                            <tbody class="bg-white divide-y divide-gray-200">
                                ${orders.map(order => `
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">${order.id}</td>
                                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${order.productName || 'N/A'}</td>
                                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${order.quantity || 0}</td>
                                        <td class="px-6 py-4 whitespace-nowrap">
                                            <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                                                order.status === 'Completed' ? 'bg-green-100 text-green-800' : 
                                                order.status === 'Pending' ? 'bg-yellow-100 text-yellow-800' : 
                                                'bg-blue-100 text-blue-800'
                                            }">
                                                ${order.status || 'Unknown'}
                                            </span>
                                        </td>
                                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                                            $${((order.quantity || 0) * (order.pricePerUnit || 0)).toFixed(2)}
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;

            const resultsSection = document.getElementById('resultsSection');
            resultsSection.classList.remove('hidden');
            resultsSection.insertBefore(stockResultsDiv, resultsSection.firstChild);
        }

        // Initialize with example scenario
        window.addEventListener('load', function() {
            document.getElementById('scenarioText').value = 
                'A smart factory monitoring system tracking temperature, pressure, and vibration sensors across different production lines during a 24-hour manufacturing cycle with automated quality control systems.';
        });
    </script>
</body>
</html>